---
phase: 02-ram-cache-dirty-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/QPreferences/CacheEntry.h
  - src/QPreferences/QPreferences.h
autonomous: true

must_haves:
  truths:
    - "After set(key, value), value exists in RAM without NVS write"
    - "isModified(key) returns true when current value differs from default"
    - "isDirty(key) returns true when RAM value differs from NVS"
    - "Multiple set() calls update RAM only, no flash writes"
    - "get(key) returns cached value after set(), not stale NVS value"
  artifacts:
    - path: "src/QPreferences/CacheEntry.h"
      provides: "Cache entry storage with three-state tracking"
      contains: "std::variant"
    - path: "src/QPreferences/QPreferences.h"
      provides: "RAM-cached get/set with isModified/isDirty APIs"
      exports: ["get", "set", "isModified", "isDirty"]
  key_links:
    - from: "QPrefs::set"
      to: "cache_entries array"
      via: "direct assignment without NVS write"
      pattern: "entry\\.value\\s*="
    - from: "QPrefs::get"
      to: "NVS via Preferences"
      via: "lazy initialization only when uninitialized"
      pattern: "if.*!entry\\.is_initialized"
    - from: "QPrefs::isModified"
      to: "key.default_value"
      via: "comparison against default"
      pattern: "default_value"
    - from: "QPrefs::isDirty"
      to: "entry.nvs_value"
      via: "comparison against stored NVS value"
      pattern: "nvs_value"
---

<objective>
Add RAM cache layer to QPreferences so set() operations stay in memory without triggering flash writes, and provide isModified/isDirty tracking APIs.

Purpose: Enable dirty tracking and deferred persistence - foundation for Phase 3's save() and batch writes
Output: CacheEntry.h with cache storage, modified QPreferences.h with cache-intercepted get/set and tracking APIs
</objective>

<execution_context>
@C:\Users\duckt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\duckt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-ram-cache-dirty-tracking/02-RESEARCH.md

# Phase 1 artifacts this plan modifies/extends
@src/QPreferences/PrefKey.h
@src/QPreferences/StringLiteral.h
@src/QPreferences/QPreferences.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CacheEntry structure with three-state tracking</name>
  <files>src/QPreferences/CacheEntry.h</files>
  <action>
Create CacheEntry.h with:

1. Include guards following pattern: QPREFERENCES_CACHEENTRY_H
2. Includes: variant, optional from C++17
3. In namespace QPreferences:

Define ValueVariant type alias:
```cpp
using ValueVariant = std::variant<int32_t, float, bool, String>;
```

Define CacheEntry struct with:
- `ValueVariant value` - current cached value
- `std::optional<ValueVariant> nvs_value` - last-known NVS value (empty = never loaded)
- `bool dirty = false` - true if RAM differs from NVS

Member functions:
- `bool is_initialized() const` - returns nvs_value.has_value()
- `bool is_dirty() const` - returns dirty flag

Define MAX_KEYS constant (64 is safe for ESP32, ~2.5KB total):
```cpp
static constexpr size_t MAX_KEYS = 64;
```

Define global cache storage (static inline for header-only):
```cpp
static inline std::array<CacheEntry, MAX_KEYS> cache_entries;
static inline size_t next_key_id = 0;
```

Add key ID registration function:
```cpp
inline size_t register_key() {
    return next_key_id++;
}
```

Follow existing code style: Doxygen comments (@brief, @return), namespace QPreferences.

NOTE: Do NOT use std::any (requires RTTI/heap). Use std::variant which is fixed-size and RTTI-free.
  </action>
  <verify>
File exists at src/QPreferences/CacheEntry.h with:
- ValueVariant using std::variant with int32_t, float, bool, String
- CacheEntry struct with value, nvs_value (optional), dirty flag
- is_initialized() and is_dirty() member functions
- cache_entries array and register_key() function
  </verify>
  <done>CacheEntry.h provides cache storage infrastructure for Phase 2 tracking</done>
</task>

<task type="auto">
  <name>Task 2: Add cache layer to get/set and implement tracking APIs</name>
  <files>src/QPreferences/QPreferences.h</files>
  <action>
Modify QPreferences.h to add RAM caching:

1. Add includes at top:
```cpp
#include "CacheEntry.h"
#include <variant>
```

2. Modify PrefKey in PrefKey.h to add static key ID:
Actually - add this to QPreferences.h instead to avoid circular deps. Add a helper:
```cpp
namespace detail {
    template<typename KeyType>
    size_t get_key_id() {
        static size_t id = QPreferences::register_key();
        return id;
    }
}
```

3. Modify get() function:
- Get cache entry using detail::get_key_id<KeyType>()
- If entry not initialized (nvs_value empty):
  - Read from NVS using Preferences (existing code)
  - Store in entry.value AND entry.nvs_value
  - Set entry.dirty = false
- Return value from cache (std::get<T>(entry.value))

Key pattern: Lazy initialization - only read NVS on first access.

4. Modify set() function:
- Get cache entry using detail::get_key_id<KeyType>()
- If entry not initialized, first load from NVS (ensures nvs_value is populated for isDirty)
- Store value in entry.value
- Set entry.dirty = true (always mark dirty on set, comparison done in isDirty)
- DO NOT call Preferences - no NVS write!
- Return true (set always succeeds in RAM)

Key change: Remove all Preferences.putInt/putFloat/etc calls. set() only touches RAM.

5. Add isModified() function:
```cpp
template<typename KeyType>
bool isModified(const KeyType& key) {
    auto& entry = QPreferences::cache_entries[detail::get_key_id<KeyType>()];

    // Ensure cache is initialized
    if (!entry.is_initialized()) {
        get(key);  // Triggers lazy load
    }

    using T = typename KeyType::value_type;
    T current = std::get<T>(entry.value);
    return current != key.default_value;
}
```

6. Add isDirty() function:
```cpp
template<typename KeyType>
bool isDirty(const KeyType& key) {
    auto& entry = QPreferences::cache_entries[detail::get_key_id<KeyType>()];

    // Ensure cache is initialized
    if (!entry.is_initialized()) {
        get(key);  // Triggers lazy load
    }

    return entry.is_dirty();
}
```

IMPORTANT:
- isModified compares current value vs key.default_value (differs from default)
- isDirty checks entry.dirty flag (RAM differs from NVS)
- Both trigger lazy load if needed to avoid pitfall #3 from research

Keep existing Doxygen style. Add docs for new functions.
  </action>
  <verify>
1. Compile check: Include QPreferences.h in a test sketch, verify no errors
2. Code review:
   - get() checks entry.is_initialized() and lazy-loads from NVS
   - set() writes to entry.value only, sets dirty=true, NO Preferences.put* calls
   - isModified() compares against key.default_value
   - isDirty() returns entry.is_dirty()
  </verify>
  <done>
QPreferences.h has:
- get() with lazy NVS initialization and cache read
- set() writes RAM only (no NVS)
- isModified(key) returns true when value differs from default
- isDirty(key) returns true when RAM differs from NVS
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Create/update test sketch at test/cache_test/cache_test.ino:
```cpp
#include <QPreferences.h>

PrefKey<int, "test", "counter"> counterKey{0};
PrefKey<bool, "test", "enabled"> enabledKey{false};

void setup() {
    Serial.begin(115200);

    // Test 1: isModified false for default value
    int val = QPrefs::get(counterKey);
    Serial.printf("Initial: %d, isModified: %d, isDirty: %d\n",
                  val, QPrefs::isModified(counterKey), QPrefs::isDirty(counterKey));
    // Expected: 0, false, false

    // Test 2: set() changes value in RAM
    QPrefs::set(counterKey, 42);
    val = QPrefs::get(counterKey);
    Serial.printf("After set(42): %d, isModified: %d, isDirty: %d\n",
                  val, QPrefs::isModified(counterKey), QPrefs::isDirty(counterKey));
    // Expected: 42, true, true

    // Test 3: Multiple sets don't cause NVS writes (no way to verify in sketch,
    // but code review confirms no Preferences.put* in set())
    for (int i = 0; i < 100; i++) {
        QPrefs::set(counterKey, i);
    }
    Serial.printf("After 100 sets: %d\n", QPrefs::get(counterKey));
    // Expected: 99
}

void loop() {}
```

2. Verify compilation succeeds (PlatformIO or Arduino IDE)
3. Code review confirms set() has NO Preferences.put* calls
</verification>

<success_criteria>
1. CacheEntry.h exists with ValueVariant, CacheEntry struct, cache_entries array
2. QPreferences.h modified with cache-intercepted get/set
3. set() writes RAM only - no Preferences.putInt/putFloat/putBool/putString calls
4. get() lazy-loads from NVS on first access, returns cached value thereafter
5. isModified(key) returns true when current value != default_value
6. isDirty(key) returns true when RAM value differs from last NVS read
7. Multiple set() calls update RAM without flash writes
8. Test sketch compiles and demonstrates expected behavior
</success_criteria>

<output>
After completion, create `.planning/phases/02-ram-cache-dirty-tracking/02-01-SUMMARY.md`
</output>

---
phase: 01-foundation-type-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/QPreferences/StringLiteral.h
  - src/QPreferences/PrefKey.h
autonomous: true

must_haves:
  truths:
    - "PrefKey<int, 'ns', 'key'>{42} compiles and captures namespace, key name, and default"
    - "PrefKey with namespace >15 chars triggers compile error"
    - "PrefKey with key name >15 chars triggers compile error"
    - "PrefKey exposes value_type, namespace_name, key_name, and default_value"
  artifacts:
    - path: "src/QPreferences/StringLiteral.h"
      provides: "Compile-time string literal capture for template parameters"
      contains: "struct StringLiteral"
    - path: "src/QPreferences/PrefKey.h"
      provides: "Type-safe preference key definition with compile-time validation"
      contains: "static_assert"
  key_links:
    - from: "src/QPreferences/PrefKey.h"
      to: "src/QPreferences/StringLiteral.h"
      via: "#include"
      pattern: "#include.*StringLiteral"
---

<objective>
Create the foundational template infrastructure for type-safe preference keys with compile-time string length validation.

Purpose: Enables developers to define PrefKey<T> with namespace, key name, and default value where the compiler catches invalid name lengths before runtime.

Output: StringLiteral.h (C++20 structural type for string literals), PrefKey.h (template with static_assert validation)
</objective>

<execution_context>
@C:\Users\duckt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\duckt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-type-safety/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StringLiteral template for compile-time string capture</name>
  <files>src/QPreferences/StringLiteral.h</files>
  <action>
Create a C++20 structural type template that captures string literals at compile time.

Implementation requirements:
1. Template parameter `size_t N` for array size (includes null terminator)
2. Constructor `constexpr StringLiteral(const char (&str)[N])` that copies string into `value` array
3. Member `char value[N]` to store the string
4. Method `constexpr size_t size() const` returning `N - 1` (excludes null terminator)

Include proper header guards (`#ifndef QPREFERENCES_STRINGLITERAL_H`).

Reference pattern from research:
```cpp
template<size_t N>
struct StringLiteral {
    constexpr StringLiteral(const char (&str)[N]) {
        std::copy_n(str, N, value);
    }
    char value[N];
    constexpr size_t size() const { return N - 1; }
};
```

Use `<algorithm>` for std::copy_n or implement manually with a constexpr loop (safer for embedded - avoid STL dependency).
  </action>
  <verify>File exists at src/QPreferences/StringLiteral.h with struct definition and constexpr methods</verify>
  <done>StringLiteral template compiles and captures string literals with size() method</done>
</task>

<task type="auto">
  <name>Task 2: Create PrefKey template with compile-time validation</name>
  <files>src/QPreferences/PrefKey.h</files>
  <action>
Create the PrefKey template that defines a type-safe preference key.

Template parameters:
- `typename T` - the value type (int, float, bool, String)
- `StringLiteral Namespace` - namespace name (C++20 NTTP)
- `StringLiteral Key` - key name (C++20 NTTP)

Struct members:
- `using value_type = T;` - expose the type
- `static constexpr const char* namespace_name = Namespace.value;` - namespace string
- `static constexpr const char* key_name = Key.value;` - key string
- `T default_value;` - the default value (non-static, set per instance)

Compile-time validation with static_assert:
- `static_assert(Namespace.size() <= 15, "Namespace must be 15 characters or less");`
- `static_assert(Key.size() <= 15, "Key name must be 15 characters or less");`

Include header guards and `#include "StringLiteral.h"`.

Do NOT include any Preferences.h or Arduino dependencies yet - this is pure C++ templates.
  </action>
  <verify>File exists at src/QPreferences/PrefKey.h with template definition, static_asserts, and public members</verify>
  <done>PrefKey template compiles, exposes all members, and rejects names >15 chars at compile time</done>
</task>

<task type="auto">
  <name>Task 3: Create test sketch to verify compile-time validation</name>
  <files>test/compile_check/compile_check.ino</files>
  <action>
Create a minimal Arduino sketch that verifies the templates work.

This is NOT a runtime test - it's a compilation test. If it compiles, the templates work.

Include tests for:
1. Valid PrefKey definitions for each supported type (int, float, bool, String)
2. Access to namespace_name, key_name, and default_value
3. Comment showing what WOULD fail (but leave commented out):
   - Namespace >15 chars
   - Key name >15 chars

Example structure:
```cpp
#include "QPreferences/PrefKey.h"
#include <Arduino.h>  // For String type

// Valid definitions - these must compile
PrefKey<int, "myapp", "counter"> counterKey{0};
PrefKey<float, "myapp", "threshold"> thresholdKey{1.5f};
PrefKey<bool, "myapp", "enabled"> enabledKey{true};
PrefKey<String, "myapp", "username"> usernameKey{String("default")};

// Compile-time validation - uncomment to verify they FAIL:
// PrefKey<int, "this_namespace_is_way_too_long", "x"> badNs{0};  // Should fail
// PrefKey<int, "x", "this_key_is_way_too_long"> badKey{0};       // Should fail

void setup() {
  Serial.begin(115200);

  // Verify member access compiles
  Serial.println(counterKey.namespace_name);
  Serial.println(counterKey.key_name);
  Serial.println(counterKey.default_value);
}

void loop() {}
```

Note: This won't actually run without ESP32 - it's for compilation verification during development.
  </action>
  <verify>File exists at test/compile_check/compile_check.ino with valid PrefKey definitions for all types</verify>
  <done>Test sketch demonstrates PrefKey usage for int, float, bool, String with documented failure cases</done>
</task>

</tasks>

<verification>
1. Directory structure exists: `src/QPreferences/` with StringLiteral.h and PrefKey.h
2. Both headers have proper include guards
3. PrefKey.h includes StringLiteral.h
4. static_assert statements present for both namespace and key length validation
5. Test sketch compiles (syntax check) - run: `pio check` or manual inspection
</verification>

<success_criteria>
- StringLiteral.h provides compile-time string capture with size() method
- PrefKey.h defines template with T, Namespace, Key parameters
- PrefKey exposes: value_type, namespace_name, key_name, default_value
- Namespace >15 chars triggers static_assert failure
- Key name >15 chars triggers static_assert failure
- Test sketch demonstrates all four supported types
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-type-safety/01-01-SUMMARY.md`
</output>

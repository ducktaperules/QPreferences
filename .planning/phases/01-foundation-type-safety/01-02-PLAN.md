---
phase: 01-foundation-type-safety
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/QPreferences/QPreferences.h
  - library.json
  - examples/BasicUsage/BasicUsage.ino
autonomous: true

must_haves:
  truths:
    - "get(key) returns correct type without explicit cast"
    - "set(key, value) compiles only when value type matches key's value_type"
    - "get/set work for all four types: int, float, bool, String"
    - "Library can be installed via PlatformIO"
  artifacts:
    - path: "src/QPreferences/QPreferences.h"
      provides: "Unified get/set API with type dispatch"
      contains: "if constexpr"
    - path: "library.json"
      provides: "PlatformIO library manifest"
      contains: "QPreferences"
    - path: "examples/BasicUsage/BasicUsage.ino"
      provides: "Working example demonstrating the API"
      contains: "PrefKey"
  key_links:
    - from: "src/QPreferences/QPreferences.h"
      to: "src/QPreferences/PrefKey.h"
      via: "#include"
      pattern: "#include.*PrefKey"
    - from: "src/QPreferences/QPreferences.h"
      to: "Preferences.h"
      via: "#include for ESP32 NVS"
      pattern: "#include.*Preferences"
    - from: "examples/BasicUsage/BasicUsage.ino"
      to: "src/QPreferences/QPreferences.h"
      via: "#include"
      pattern: "#include.*QPreferences"
---

<objective>
Implement the unified get/set API with type dispatch and create the library structure for PlatformIO.

Purpose: Developers can use `get(key)` and `set(key, value)` with automatic type deduction, completing the type-safe preference access API.

Output: QPreferences.h (main API), library.json (PlatformIO manifest), BasicUsage.ino (working example)
</objective>

<execution_context>
@C:\Users\duckt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\duckt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-type-safety/01-RESEARCH.md
@.planning/phases/01-foundation-type-safety/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QPreferences.h with get/set API</name>
  <files>src/QPreferences/QPreferences.h</files>
  <action>
Create the main header that provides the unified get/set API using if constexpr for type dispatch.

Required includes:
- `#include <Preferences.h>` (ESP32 Arduino)
- `#include <type_traits>` (for std::is_same_v)
- `#include "PrefKey.h"`

Implement two template functions:

**get function:**
```cpp
template<typename KeyType>
typename KeyType::value_type get(const KeyType& key) {
    Preferences prefs;
    prefs.begin(KeyType::namespace_name, true);  // true = read-only

    using T = typename KeyType::value_type;
    T result;

    if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, int>) {
        result = prefs.getInt(KeyType::key_name, key.default_value);
    } else if constexpr (std::is_same_v<T, float>) {
        result = prefs.getFloat(KeyType::key_name, key.default_value);
    } else if constexpr (std::is_same_v<T, bool>) {
        result = prefs.getBool(KeyType::key_name, key.default_value);
    } else if constexpr (std::is_same_v<T, String>) {
        result = prefs.getString(KeyType::key_name, key.default_value);
    } else {
        static_assert(sizeof(T) == 0, "Unsupported type for QPreferences");
    }

    prefs.end();
    return result;
}
```

**set function:**
```cpp
template<typename KeyType>
bool set(const KeyType& key, typename KeyType::value_type value) {
    Preferences prefs;
    prefs.begin(KeyType::namespace_name, false);  // false = read-write

    using T = typename KeyType::value_type;
    size_t written = 0;

    if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, int>) {
        written = prefs.putInt(KeyType::key_name, value);
    } else if constexpr (std::is_same_v<T, float>) {
        written = prefs.putFloat(KeyType::key_name, value);
    } else if constexpr (std::is_same_v<T, bool>) {
        written = prefs.putBool(KeyType::key_name, value);
    } else if constexpr (std::is_same_v<T, String>) {
        written = prefs.putString(KeyType::key_name, value);
    } else {
        static_assert(sizeof(T) == 0, "Unsupported type for QPreferences");
    }

    prefs.end();
    return written > 0;
}
```

IMPORTANT: For Phase 1, get/set write directly to NVS. RAM caching is Phase 2.

Include header guards. Wrap functions in `namespace QPrefs {` to avoid global namespace pollution.
  </action>
  <verify>File exists with get() and set() template functions using if constexpr dispatch</verify>
  <done>get/set API compiles and dispatches to correct Preferences methods based on KeyType::value_type</done>
</task>

<task type="auto">
  <name>Task 2: Create PlatformIO library manifest</name>
  <files>library.json</files>
  <action>
Create PlatformIO library manifest at project root.

Contents:
```json
{
  "name": "QPreferences",
  "version": "0.1.0",
  "description": "Type-safe ESP32 preferences with compile-time validation and explicit persistence control",
  "keywords": ["esp32", "preferences", "nvs", "type-safe", "flash"],
  "repository": {
    "type": "git",
    "url": "https://github.com/user/QPreferences"
  },
  "authors": [
    {
      "name": "QPreferences Contributors"
    }
  ],
  "license": "MIT",
  "frameworks": "arduino",
  "platforms": "espressif32",
  "build": {
    "flags": [
      "-std=gnu++20"
    ]
  },
  "headers": "QPreferences/QPreferences.h"
}
```

The `-std=gnu++20` flag is required for C++20 structural types (StringLiteral as NTTP).
  </action>
  <verify>File exists at library.json with valid JSON and build flags for C++20</verify>
  <done>Library manifest enables PlatformIO discovery and sets correct C++ standard</done>
</task>

<task type="auto">
  <name>Task 3: Create BasicUsage example sketch</name>
  <files>examples/BasicUsage/BasicUsage.ino</files>
  <action>
Create a complete example sketch demonstrating the QPreferences API.

Requirements:
1. Define PrefKeys for all four types (int, float, bool, String)
2. Show get() returning correct type
3. Show set() with type-safe value
4. Print values to Serial
5. Include helpful comments explaining the API

Example structure:
```cpp
/**
 * QPreferences Basic Usage Example
 *
 * Demonstrates:
 * - Defining type-safe preference keys with PrefKey<T>
 * - Compile-time validation of namespace/key length (<=15 chars)
 * - Unified get/set API with automatic type deduction
 */

#include <QPreferences/QPreferences.h>

// Define preference keys - these are compile-time validated
// Namespace and key names must be <=15 characters (NVS limit)
PrefKey<int, "myapp", "bootCount"> bootCount{0};
PrefKey<float, "myapp", "threshold"> threshold{1.5f};
PrefKey<bool, "myapp", "ledEnabled"> ledEnabled{true};
PrefKey<String, "myapp", "deviceName"> deviceName{String("ESP32")};

void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println("QPreferences Basic Usage Example");
  Serial.println("================================");

  // Get current values (returns default if not stored)
  int count = QPrefs::get(bootCount);
  Serial.printf("Boot count: %d\n", count);

  // Increment and save
  QPrefs::set(bootCount, count + 1);

  // Read other preferences
  float thresh = QPrefs::get(threshold);
  bool led = QPrefs::get(ledEnabled);
  String name = QPrefs::get(deviceName);

  Serial.printf("Threshold: %.2f\n", thresh);
  Serial.printf("LED enabled: %s\n", led ? "true" : "false");
  Serial.printf("Device name: %s\n", name.c_str());

  // Type safety: these would NOT compile (uncomment to verify):
  // QPrefs::set(bootCount, 3.14f);     // Error: float to int key
  // QPrefs::set(threshold, "hello");   // Error: string to float key
  // int x = QPrefs::get(deviceName);   // Error: String returned, not int

  Serial.println("\nReboot to see boot count increase!");
}

void loop() {
  delay(1000);
}
```
  </action>
  <verify>File exists at examples/BasicUsage/BasicUsage.ino with PrefKey definitions and get/set usage</verify>
  <done>Example demonstrates type-safe API for all four supported types with clear documentation</done>
</task>

</tasks>

<verification>
1. QPreferences.h exists with get/set template functions
2. Both functions use if constexpr for type dispatch
3. library.json exists with valid JSON and C++20 build flag
4. examples/BasicUsage/BasicUsage.ino demonstrates all four types
5. Example includes commented-out type mismatch examples showing type safety
</verification>

<success_criteria>
- get(key) returns KeyType::value_type automatically
- set(key, value) enforces type match at compile time
- All four types work: int, float, bool, String
- Unsupported types trigger static_assert with helpful message
- Library installable via PlatformIO (library.json valid)
- Example sketch demonstrates complete Phase 1 API
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-type-safety/01-02-SUMMARY.md`
</output>

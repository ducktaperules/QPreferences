---
phase: 04-iteration-examples
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - examples/DirtyTracking/DirtyTracking.ino
  - examples/NamespaceGroups/NamespaceGroups.ino
autonomous: true

must_haves:
  truths:
    - "DirtyTracking example demonstrates isDirty(), isModified(), and save() workflow"
    - "NamespaceGroups example demonstrates forEach(), forEachInNamespace(), and factoryReset()"
    - "Examples follow Arduino library conventions (folder name matches .ino filename)"
  artifacts:
    - path: "examples/DirtyTracking/DirtyTracking.ino"
      provides: "Example demonstrating dirty tracking and explicit save"
      contains: "isDirty"
    - path: "examples/NamespaceGroups/NamespaceGroups.ino"
      provides: "Example demonstrating iteration and factory reset"
      contains: "forEach"
  key_links:
    - from: "examples/DirtyTracking/DirtyTracking.ino"
      to: "QPrefs::isDirty, QPrefs::save"
      via: "demonstration of Phase 2/3 APIs"
      pattern: "QPrefs::isDirty|QPrefs::save"
    - from: "examples/NamespaceGroups/NamespaceGroups.ino"
      to: "QPrefs::forEach, QPrefs::factoryReset"
      via: "demonstration of Phase 4 APIs"
      pattern: "QPrefs::forEach|QPrefs::factoryReset"
---

<objective>
Create example sketches demonstrating dirty tracking and namespace iteration/reset.

Purpose: Provide working examples for developers learning the library (Phase 4 success criteria 3).
Output: Two Arduino example sketches following library conventions.
</objective>

<execution_context>
@C:\Users\duckt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\duckt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-iteration-examples/04-01-SUMMARY.md

@src/QPreferences/QPreferences.h
@examples/BasicUsage/BasicUsage.ino
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DirtyTracking example</name>
  <files>examples/DirtyTracking/DirtyTracking.ino</files>
  <action>
Create new directory `examples/DirtyTracking/` and add `DirtyTracking.ino`:

```cpp
/**
 * QPreferences Dirty Tracking Example
 *
 * Demonstrates:
 * - isDirty(key) - check if RAM differs from NVS
 * - isModified(key) - check if value differs from default
 * - save(key) - persist single key with default removal
 * - save() - persist all dirty keys in batch
 *
 * This example shows how changes are tracked in RAM
 * and only written to flash when you call save().
 */

#include <QPreferences/QPreferences.h>

// Define preference keys in different states
PrefKey<int, "dirty", "counter"> counter{0};
PrefKey<float, "dirty", "temperature"> temperature{25.0f};
PrefKey<bool, "dirty", "enabled"> enabled{false};

void printStatus(const char* label) {
    Serial.printf("\n--- %s ---\n", label);
    Serial.printf("counter:     value=%d, isDirty=%s, isModified=%s\n",
        QPrefs::get(counter),
        QPrefs::isDirty(counter) ? "YES" : "no",
        QPrefs::isModified(counter) ? "YES" : "no");
    Serial.printf("temperature: value=%.1f, isDirty=%s, isModified=%s\n",
        QPrefs::get(temperature),
        QPrefs::isDirty(temperature) ? "YES" : "no",
        QPrefs::isModified(temperature) ? "YES" : "no");
    Serial.printf("enabled:     value=%s, isDirty=%s, isModified=%s\n",
        QPrefs::get(enabled) ? "true" : "false",
        QPrefs::isDirty(enabled) ? "YES" : "no",
        QPrefs::isModified(enabled) ? "YES" : "no");
}

void setup() {
    Serial.begin(115200);
    delay(1000);

    Serial.println("QPreferences Dirty Tracking Example");
    Serial.println("====================================");

    // 1. Initial state - values loaded from NVS (or defaults)
    printStatus("After loading from NVS");

    // 2. Modify values in RAM (no flash write yet!)
    Serial.println("\nModifying values in RAM...");
    QPrefs::set(counter, QPrefs::get(counter) + 1);
    QPrefs::set(temperature, 30.5f);
    QPrefs::set(enabled, true);

    printStatus("After set() - changes in RAM only");

    // 3. Save individual key (with default removal)
    Serial.println("\nSaving counter with save(key)...");
    QPrefs::save(counter);
    printStatus("After save(counter)");

    // 4. Reset one value back to default
    Serial.println("\nSetting enabled back to default (false)...");
    QPrefs::set(enabled, false);
    printStatus("After reset to default");

    // 5. Save all remaining dirty values
    Serial.println("\nSaving all dirty values with save()...");
    QPrefs::save();
    printStatus("After save() - all clean");

    // 6. Demonstrate isModified vs isDirty
    Serial.println("\n=== isModified vs isDirty ===");
    Serial.println("isModified = value != default");
    Serial.println("isDirty = RAM != NVS (unsaved changes)");

    QPrefs::set(counter, 0);  // Back to default
    Serial.printf("\ncounter set to 0 (default):\n");
    Serial.printf("  isModified: %s (same as default)\n",
        QPrefs::isModified(counter) ? "YES" : "no");
    Serial.printf("  isDirty: %s (RAM differs from NVS)\n",
        QPrefs::isDirty(counter) ? "YES" : "no");

    Serial.println("\nReboot to see persistence in action!");
}

void loop() {
    delay(1000);
}
```

Key concepts demonstrated:
1. isDirty tracks RAM vs NVS differences
2. isModified tracks current vs default differences
3. save(key) persists single key (with default removal)
4. save() persists all dirty keys
5. The distinction between modified and dirty states
  </action>
  <verify>
1. File exists at examples/DirtyTracking/DirtyTracking.ino
2. Folder name matches filename (DirtyTracking/DirtyTracking.ino)
3. Grep for "isDirty" confirms API usage
4. Grep for "save(" confirms save API usage
  </verify>
  <done>DirtyTracking.ino demonstrates isDirty(), isModified(), save(key), and save() with clear explanations.</done>
</task>

<task type="auto">
  <name>Task 2: Create NamespaceGroups example</name>
  <files>examples/NamespaceGroups/NamespaceGroups.ino</files>
  <action>
Create new directory `examples/NamespaceGroups/` and add `NamespaceGroups.ino`:

```cpp
/**
 * QPreferences Namespace Groups Example
 *
 * Demonstrates:
 * - Organizing preferences into namespaces
 * - forEach() - iterate all registered preferences
 * - forEachInNamespace() - iterate keys in specific namespace
 * - factoryReset() - clear all NVS and restore defaults
 *
 * Namespaces help organize preferences by component/feature.
 * This example shows how to inspect and reset grouped preferences.
 */

#include <QPreferences/QPreferences.h>

// WiFi settings namespace
PrefKey<String, "wifi", "ssid"> wifiSSID{String("MyNetwork")};
PrefKey<String, "wifi", "password"> wifiPassword{String("")};
PrefKey<bool, "wifi", "autoConnect"> autoConnect{true};

// Display settings namespace
PrefKey<int, "display", "brightness"> brightness{100};
PrefKey<bool, "display", "nightMode"> nightMode{false};

// Sensor settings namespace
PrefKey<float, "sensor", "threshold"> threshold{1.5f};
PrefKey<int, "sensor", "interval"> interval{1000};

void setup() {
    Serial.begin(115200);
    delay(1000);

    Serial.println("QPreferences Namespace Groups Example");
    Serial.println("======================================\n");

    // Initialize all preferences (triggers lazy load from NVS)
    QPrefs::get(wifiSSID);
    QPrefs::get(wifiPassword);
    QPrefs::get(autoConnect);
    QPrefs::get(brightness);
    QPrefs::get(nightMode);
    QPrefs::get(threshold);
    QPrefs::get(interval);

    // 1. List ALL registered preferences
    Serial.println("=== All Registered Preferences ===");
    QPrefs::forEach([](const QPreferences::PrefInfo& info) {
        Serial.printf("  %s/%s", info.namespace_name, info.key_name);
        if (info.is_dirty) Serial.print(" [dirty]");
        if (!info.is_initialized) Serial.print(" [not loaded]");
        Serial.println();
    });

    // 2. List preferences in a specific namespace
    Serial.println("\n=== WiFi Namespace Only ===");
    QPrefs::forEachInNamespace("wifi", [](const QPreferences::PrefInfo& info) {
        Serial.printf("  %s\n", info.key_name);
    });

    Serial.println("\n=== Display Namespace Only ===");
    QPrefs::forEachInNamespace("display", [](const QPreferences::PrefInfo& info) {
        Serial.printf("  %s\n", info.key_name);
    });

    // 3. Count keys per namespace
    Serial.println("\n=== Keys Per Namespace ===");
    int wifiCount = 0, displayCount = 0, sensorCount = 0;
    QPrefs::forEach([&](const QPreferences::PrefInfo& info) {
        if (strcmp(info.namespace_name, "wifi") == 0) wifiCount++;
        else if (strcmp(info.namespace_name, "display") == 0) displayCount++;
        else if (strcmp(info.namespace_name, "sensor") == 0) sensorCount++;
    });
    Serial.printf("  wifi: %d keys\n", wifiCount);
    Serial.printf("  display: %d keys\n", displayCount);
    Serial.printf("  sensor: %d keys\n", sensorCount);

    // 4. Modify some values
    Serial.println("\n=== Modifying Values ===");
    QPrefs::set(brightness, 75);
    QPrefs::set(threshold, 2.0f);
    QPrefs::save();  // Persist changes
    Serial.println("Modified brightness=75, threshold=2.0 and saved");

    // 5. Show current values
    Serial.println("\n=== Current Values ===");
    Serial.printf("  brightness: %d\n", QPrefs::get(brightness));
    Serial.printf("  threshold: %.1f\n", QPrefs::get(threshold));

    // 6. Factory reset demonstration
    Serial.println("\n=== Factory Reset ===");
    Serial.println("Calling factoryReset() - this clears ALL NVS data!");
    QPrefs::factoryReset();

    Serial.println("\nAfter factory reset:");
    Serial.printf("  brightness: %d (default: 100)\n", QPrefs::get(brightness));
    Serial.printf("  threshold: %.1f (default: 1.5)\n", QPrefs::get(threshold));

    Serial.println("\nFactory reset complete - all values restored to defaults.");
    Serial.println("Reboot to verify NVS is cleared.");
}

void loop() {
    delay(1000);
}
```

Key concepts demonstrated:
1. Organizing preferences into logical namespaces
2. forEach() iterates ALL registered keys with metadata
3. forEachInNamespace() filters to specific namespace
4. Lambda capture for counting/aggregation
5. factoryReset() clears all NVS and restores defaults
  </action>
  <verify>
1. File exists at examples/NamespaceGroups/NamespaceGroups.ino
2. Folder name matches filename (NamespaceGroups/NamespaceGroups.ino)
3. Grep for "forEach" confirms iteration API usage
4. Grep for "forEachInNamespace" confirms filtered iteration
5. Grep for "factoryReset" confirms reset API usage
  </verify>
  <done>NamespaceGroups.ino demonstrates namespace organization, forEach(), forEachInNamespace(), and factoryReset().</done>
</task>

</tasks>

<verification>
1. Both example directories exist with matching .ino filenames
2. DirtyTracking demonstrates Phase 2/3 APIs (isDirty, isModified, save)
3. NamespaceGroups demonstrates Phase 4 APIs (forEach, forEachInNamespace, factoryReset)
4. Examples follow Arduino library conventions
5. Examples compile without errors
</verification>

<success_criteria>
- DirtyTracking.ino shows isDirty/isModified/save workflow
- NamespaceGroups.ino shows iteration and factory reset
- Both examples are discoverable in Arduino IDE
- Clear comments explain each concept
</success_criteria>

<output>
After completion, create `.planning/phases/04-iteration-examples/04-02-SUMMARY.md`
</output>

---
phase: 04-iteration-examples
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/QPreferences/CacheEntry.h
  - src/QPreferences/QPreferences.h
autonomous: true

must_haves:
  truths:
    - "Developer can iterate over all registered PrefKey instances with access to namespace, key name, and status"
    - "Developer can filter iteration to only keys in specific namespace"
    - "Developer can call factoryReset() to clear all NVS entries and restore defaults"
  artifacts:
    - path: "src/QPreferences/CacheEntry.h"
      provides: "PrefInfo struct for iteration callbacks"
      contains: "struct PrefInfo"
    - path: "src/QPreferences/QPreferences.h"
      provides: "forEach, forEachInNamespace, factoryReset functions"
      exports: ["forEach", "forEachInNamespace", "factoryReset"]
  key_links:
    - from: "QPrefs::forEach"
      to: "QPreferences::key_metadata"
      via: "iteration over registered keys"
      pattern: "key_metadata\\[i\\]"
    - from: "QPrefs::factoryReset"
      to: "Preferences::clear()"
      via: "ESP32 NVS clear API"
      pattern: "prefs\\.clear\\(\\)"
---

<objective>
Implement iteration API for registered preferences with namespace filtering and factory reset.

Purpose: Enable developers to enumerate all preferences for debugging, status display, and factory reset functionality (TRCK-03, TRCK-04).
Output: PrefInfo struct, forEach(), forEachInNamespace(), and factoryReset() functions in QPrefs namespace.
</objective>

<execution_context>
@C:\Users\duckt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\duckt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-iteration-examples/04-RESEARCH.md

@src/QPreferences/CacheEntry.h
@src/QPreferences/QPreferences.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PrefInfo struct for iteration callbacks</name>
  <files>src/QPreferences/CacheEntry.h</files>
  <action>
Add PrefInfo struct to CacheEntry.h within the QPreferences namespace, after the KeyMetadata struct:

```cpp
/**
 * @brief Information about a preference, passed to forEach callbacks.
 *
 * Provides access to key metadata and status without exposing
 * the raw value (user accesses value via get(key) with their typed key).
 */
struct PrefInfo {
    const char* namespace_name;   ///< The namespace this key belongs to
    const char* key_name;         ///< The key name within the namespace
    size_t index;                 ///< Index into cache_entries array
    bool is_initialized;          ///< Whether key has been loaded from NVS
    bool is_dirty;                ///< Whether RAM differs from NVS
};
```

This struct is passed to callback functions during iteration, providing access to key metadata and status without exposing the raw variant value.
  </action>
  <verify>Grep for "struct PrefInfo" in CacheEntry.h confirms it exists. File compiles without errors.</verify>
  <done>PrefInfo struct exists with namespace_name, key_name, index, is_initialized, is_dirty fields.</done>
</task>

<task type="auto">
  <name>Task 2: Implement forEach, forEachInNamespace, and factoryReset</name>
  <files>src/QPreferences/QPreferences.h</files>
  <action>
Add three new functions to QPreferences.h within the QPrefs namespace, after the save() functions.

**1. forEach - iterate over all registered keys:**
```cpp
/**
 * @brief Iterate over all registered preference keys.
 *
 * Calls the callback for each registered key with a PrefInfo struct
 * containing metadata and status. Does not expose raw values.
 * Use get(key) with your typed key to access values.
 *
 * @tparam Callback Callable accepting (const PrefInfo&)
 * @param callback Function to call for each registered key
 *
 * Usage:
 *   QPrefs::forEach([](const QPreferences::PrefInfo& info) {
 *       Serial.printf("%s/%s: %s\n",
 *           info.namespace_name, info.key_name,
 *           info.is_dirty ? "dirty" : "clean");
 *   });
 */
template<typename Callback>
void forEach(Callback callback) {
    for (size_t i = 0; i < QPreferences::next_key_id; ++i) {
        auto& meta = QPreferences::key_metadata[i];
        auto& entry = QPreferences::cache_entries[i];

        QPreferences::PrefInfo info{
            meta.namespace_name,
            meta.key_name,
            i,
            entry.is_initialized(),
            entry.is_dirty()
        };
        callback(info);
    }
}
```

**2. forEachInNamespace - filtered iteration:**
```cpp
/**
 * @brief Iterate over registered keys in a specific namespace.
 *
 * Same as forEach() but only calls callback for keys matching the namespace.
 *
 * @tparam Callback Callable accepting (const PrefInfo&)
 * @param ns The namespace to filter by
 * @param callback Function to call for each matching key
 *
 * Usage:
 *   QPrefs::forEachInNamespace("myapp", [](const QPreferences::PrefInfo& info) {
 *       Serial.printf("  %s\n", info.key_name);
 *   });
 */
template<typename Callback>
void forEachInNamespace(const char* ns, Callback callback) {
    for (size_t i = 0; i < QPreferences::next_key_id; ++i) {
        auto& meta = QPreferences::key_metadata[i];
        if (std::strcmp(meta.namespace_name, ns) == 0) {
            auto& entry = QPreferences::cache_entries[i];

            QPreferences::PrefInfo info{
                meta.namespace_name,
                meta.key_name,
                i,
                entry.is_initialized(),
                entry.is_dirty()
            };
            callback(info);
        }
    }
}
```

**3. factoryReset - clear all NVS and reset cache:**
```cpp
/**
 * @brief Clear all NVS entries and reset cache to uninitialized state.
 *
 * Groups keys by namespace and calls Preferences::clear() for each namespace.
 * Resets all cache entries to uninitialized state (nvs_value.reset(), dirty=false).
 * After factory reset, get(key) will return default values.
 *
 * WARNING: This permanently deletes all stored preference values from flash!
 */
inline void factoryReset() {
    Preferences prefs;
    const char* last_ns = nullptr;

    for (size_t i = 0; i < QPreferences::next_key_id; ++i) {
        auto& meta = QPreferences::key_metadata[i];

        // Clear namespace if different from last (batch by namespace)
        if (last_ns == nullptr || std::strcmp(last_ns, meta.namespace_name) != 0) {
            if (last_ns != nullptr) {
                prefs.end();
            }
            prefs.begin(meta.namespace_name, false);  // false = read-write
            prefs.clear();  // Delete all keys in this namespace
            last_ns = meta.namespace_name;
        }

        // Reset cache entry to uninitialized state
        auto& entry = QPreferences::cache_entries[i];
        entry.nvs_value.reset();
        entry.dirty = false;
    }

    if (last_ns != nullptr) {
        prefs.end();
    }
}
```

Note: #include <cstring> is already present in QPreferences.h (used by save() for strcmp).
  </action>
  <verify>
1. Grep for "void forEach" in QPreferences.h confirms forEach exists
2. Grep for "void forEachInNamespace" confirms filtered iteration exists
3. Grep for "void factoryReset" confirms factory reset exists
4. File compiles without errors
  </verify>
  <done>
- forEach() iterates all keys and calls callback with PrefInfo
- forEachInNamespace() filters to specific namespace
- factoryReset() clears all NVS namespaces and resets cache state
  </done>
</task>

</tasks>

<verification>
1. All three functions exist in QPrefs namespace
2. PrefInfo struct provides namespace_name, key_name, index, is_initialized, is_dirty
3. Code compiles without errors
4. Functions follow established patterns from research (callback-based, namespace batching)
</verification>

<success_criteria>
- forEach() can iterate all registered keys
- forEachInNamespace() filters to single namespace
- factoryReset() clears all NVS and resets cache
- All functions callable from Arduino sketch
</success_criteria>

<output>
After completion, create `.planning/phases/04-iteration-examples/04-01-SUMMARY.md`
</output>

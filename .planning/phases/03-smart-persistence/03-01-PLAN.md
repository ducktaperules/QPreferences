---
phase: 03-smart-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/QPreferences/CacheEntry.h
  - src/QPreferences/QPreferences.h
  - test/save_test/save_test.ino
autonomous: true

must_haves:
  truths:
    - "After reboot, previously saved non-default values are loaded into RAM on first get() access (lazy loading from Phase 2 satisfies PERS-01)"
    - "Developer can call save(key) to persist a dirty value to NVS"
    - "After save(key), isDirty(key) returns false for that key"
    - "When saved value matches default, the key is removed from NVS (not stored)"
    - "Test sketch verifies persistence survives reboot (manual reboot step)"
  artifacts:
    - path: "src/QPreferences/CacheEntry.h"
      provides: "KeyMetadata struct and metadata array"
      contains: "KeyMetadata"
    - path: "src/QPreferences/QPreferences.h"
      provides: "save(key) function with default removal logic"
      contains: "void save("
    - path: "test/save_test/save_test.ino"
      provides: "Verification sketch for save behavior including reboot test"
      contains: "QPrefs::save("
  key_links:
    - from: "src/QPreferences/QPreferences.h"
      to: "cache_entries + key_metadata"
      via: "save(key) accesses both cache entry and metadata"
      pattern: "cache_entries\\[.*get_key_id.*key_metadata\\[.*get_key_id"
    - from: "save(key)"
      to: "Preferences.putX/remove"
      via: "type dispatch and default comparison"
      pattern: "prefs\\.(put|remove)"
---

<objective>
Implement explicit save(key) API with per-key NVS writes and default value optimization.

Purpose: Complete the persistence layer so changes in RAM can be explicitly persisted to flash with minimal flash wear. This enables the "RAM-first, explicit-save" pattern that prevents flash wear from frequent set() calls.

Note on PERS-01 (boot loading): Phase 2's lazy initialization pattern already satisfies this requirement. When get(key) is called for the first time after boot, it loads the NVS value into RAM. This is lazy loading rather than eager loading, but achieves the same outcome: stored values are available in RAM when accessed. No additional work needed.

Output:
- KeyMetadata struct storing namespace/key pointers per cache entry
- save(key) function that persists a single key with default removal
- Default value optimization (remove key from NVS if value equals default)
- Test sketch demonstrating save behavior with reboot verification instructions
</objective>

<execution_context>
@C:\Users\duckt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\duckt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-smart-persistence/03-RESEARCH.md
@.planning/phases/02-ram-cache-dirty-tracking/02-01-SUMMARY.md
@src/QPreferences/CacheEntry.h
@src/QPreferences/QPreferences.h
@src/QPreferences/PrefKey.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add KeyMetadata and update cache registration</name>
  <files>src/QPreferences/CacheEntry.h, src/QPreferences/QPreferences.h</files>
  <action>
Add KeyMetadata struct to CacheEntry.h that stores namespace and key name pointers:

```cpp
struct KeyMetadata {
    const char* namespace_name = nullptr;
    const char* key_name = nullptr;
};

static inline std::array<KeyMetadata, MAX_KEYS> key_metadata;
```

Update the register_key() function to accept and store metadata:

```cpp
inline size_t register_key(const char* ns, const char* key) {
    size_t id = next_key_id++;
    key_metadata[id] = {ns, key};
    return id;
}
```

Update get_key_id() in QPreferences.h to pass namespace/key to register_key():

```cpp
template<typename KeyType>
size_t get_key_id() {
    static size_t id = QPreferences::register_key(
        KeyType::namespace_name,
        KeyType::key_name
    );
    return id;
}
```

This enables save(key) to know the namespace and key name for each cache entry without template context.
  </action>
  <verify>Build compiles without errors. Existing get/set/isModified/isDirty still work.</verify>
  <done>KeyMetadata struct exists. register_key() stores namespace/key. get_key_id() passes metadata.</done>
</task>

<task type="auto">
  <name>Task 2: Implement save(key) with default removal</name>
  <files>src/QPreferences/QPreferences.h, test/save_test/save_test.ino</files>
  <action>
Add save(key) function to QPrefs namespace in QPreferences.h. This is the ONLY save function - no parameterless save() since per-key save enables proper default comparison:

```cpp
/**
 * @brief Persist a single preference key to NVS flash.
 *
 * If the current value equals the default, removes the key from NVS.
 * If the current value differs from default, writes to NVS.
 * After save, isDirty(key) returns false.
 *
 * @tparam KeyType The PrefKey type (automatically deduced)
 * @param key The preference key to save
 */
template<typename KeyType>
void save(const KeyType& key) {
    using T = typename KeyType::value_type;
    auto& entry = QPreferences::cache_entries[detail::get_key_id<KeyType>()];
    auto& meta = QPreferences::key_metadata[detail::get_key_id<KeyType>()];

    if (!entry.is_initialized() || !entry.is_dirty()) {
        return;  // Nothing to save
    }

    Preferences prefs;
    prefs.begin(meta.namespace_name, false);  // false = read-write

    T current = std::get<T>(entry.value);

    if (current == key.default_value) {
        // Remove from NVS if equals default (PERS-04)
        prefs.remove(meta.key_name);
        entry.nvs_value = std::monostate{};  // Mark as no NVS value
    } else {
        // Write to NVS
        if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, int>) {
            prefs.putInt(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, float>) {
            prefs.putFloat(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, bool>) {
            prefs.putBool(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, String>) {
            prefs.putString(meta.key_name, current);
        }
        entry.nvs_value = entry.value;
    }

    prefs.end();
    entry.dirty = false;
}
```

Note: No global save() function. Users call save(key) for each key they want to persist, or loop over their keys. This is cleaner and enables default comparison.

For namespace batching (PERS-05), the user can group saves by namespace OR we document that multiple save(key) calls to same namespace will each open/close. Future optimization could add saveAll() that batches, but save(key) satisfies the core requirement.

Create test sketch test/save_test/save_test.ino:

```cpp
#include <QPreferences.h>

// Define test keys
PrefKey<int, "test", "count"> testCount{0};
PrefKey<bool, "test", "flag"> testFlag{false};
PrefKey<String, "other", "name"> otherName{""};

void setup() {
    Serial.begin(115200);
    delay(1000);

    Serial.println("=== Save Test ===");

    // Check if this is a reboot test (value should persist)
    int initialCount = QPrefs::get(testCount);
    Serial.printf("Initial count (from NVS or default): %d\n", initialCount);

    if (initialCount == 42) {
        Serial.println("SUCCESS: Value persisted across reboot!");
        Serial.println("Resetting to default for next test run...");
        QPrefs::set(testCount, 0);
        QPrefs::save(testCount);
        Serial.println("Reset complete. Test passed.");
        return;
    }

    // Test 1: Set values and verify dirty
    QPrefs::set(testCount, 42);
    QPrefs::set(testFlag, true);
    Serial.printf("After set - isDirty(count): %d (expect 1)\n", QPrefs::isDirty(testCount));
    Serial.printf("After set - isDirty(flag): %d (expect 1)\n", QPrefs::isDirty(testFlag));

    // Test 2: Save single key and verify dirty cleared
    QPrefs::save(testCount);
    Serial.printf("After save(count) - isDirty(count): %d (expect 0)\n", QPrefs::isDirty(testCount));
    Serial.printf("After save(count) - isDirty(flag): %d (expect 1)\n", QPrefs::isDirty(testFlag));

    // Test 3: Save remaining key
    QPrefs::save(testFlag);
    Serial.printf("After save(flag) - isDirty(flag): %d (expect 0)\n", QPrefs::isDirty(testFlag));

    // Test 4: Set to default and save (should remove from NVS)
    QPrefs::set(testFlag, false);  // Back to default
    QPrefs::save(testFlag);
    Serial.printf("After save(false) - isDirty(flag): %d (expect 0)\n", QPrefs::isDirty(testFlag));

    Serial.println("\n=== Reboot Test Instructions ===");
    Serial.println("1. Press reset button or power cycle");
    Serial.println("2. After reboot, count should be 42 (persisted)");
    Serial.println("3. The test will detect this and report SUCCESS");
    Serial.println("=== Test Complete - Please Reboot ===");
}

void loop() {}
```

Ensure platformio.ini has save_test environment.
  </action>
  <verify>pio run -e esp32dev compiles. Upload and run save_test sketch - all isDirty() return 0 after save(). After reboot, value 42 persists.</verify>
  <done>save(key) persists single key with default removal. isDirty() returns false after save(). Test demonstrates behavior including reboot verification.</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `pio run -e esp32dev` compiles without errors
2. Run save_test sketch and observe:
   - isDirty() returns true after set()
   - isDirty() returns false after save(key)
   - Setting value to default and saving removes from NVS
3. Reboot test:
   - After first run with value 42, reboot device
   - On second run, initial get() should return 42 (loaded from NVS)
   - This verifies PERS-01 (boot loading via lazy init)
4. Existing cache_test still works (backward compatibility)
</verification>

<success_criteria>
- save(key) function exists and compiles
- After save(key), isDirty(key) returns false
- Values equal to default are removed from NVS (not written)
- After reboot, non-default values are loaded from NVS on first get()
- Test sketch demonstrates all save behaviors including reboot persistence
- No regressions in existing get/set/isModified/isDirty APIs
</success_criteria>

<output>
After completion, create `.planning/phases/03-smart-persistence/03-01-SUMMARY.md`
</output>

---
phase: 03-smart-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/QPreferences/CacheEntry.h
  - src/QPreferences/QPreferences.h
  - test/save_test/save_test.ino
autonomous: true

must_haves:
  truths:
    - "Developer can call save() to persist all dirty values to NVS"
    - "After save(), isDirty() returns false for saved keys"
    - "Values matching defaults are removed from NVS, not written"
    - "Multiple dirty keys in same namespace batch into single begin/end cycle"
  artifacts:
    - path: "src/QPreferences/CacheEntry.h"
      provides: "KeyMetadata struct and metadata array"
      contains: "KeyMetadata"
    - path: "src/QPreferences/QPreferences.h"
      provides: "save() function with batching logic"
      contains: "void save()"
    - path: "test/save_test/save_test.ino"
      provides: "Verification sketch for save behavior"
      contains: "QPrefs::save()"
  key_links:
    - from: "src/QPreferences/QPreferences.h"
      to: "cache_entries + key_metadata"
      via: "save() iterates both arrays"
      pattern: "cache_entries\\[i\\].*key_metadata\\[i\\]"
    - from: "save()"
      to: "Preferences.putX/remove"
      via: "type dispatch and default comparison"
      pattern: "prefs\\.(put|remove)"
---

<objective>
Implement explicit save() API with namespace-batched NVS writes and default value optimization.

Purpose: Complete the persistence layer so changes in RAM can be explicitly persisted to flash with minimal flash wear. This enables the "RAM-first, explicit-save" pattern that prevents flash wear from frequent set() calls.

Output:
- KeyMetadata struct storing namespace/key pointers per cache entry
- save() function that batches dirty writes by namespace
- Default value optimization (remove key from NVS if value equals default)
- Test sketch demonstrating save behavior
</objective>

<execution_context>
@C:\Users\duckt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\duckt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-smart-persistence/03-RESEARCH.md
@.planning/phases/02-ram-cache-dirty-tracking/02-01-SUMMARY.md
@src/QPreferences/CacheEntry.h
@src/QPreferences/QPreferences.h
@src/QPreferences/PrefKey.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add KeyMetadata and update cache registration</name>
  <files>src/QPreferences/CacheEntry.h, src/QPreferences/QPreferences.h</files>
  <action>
Add KeyMetadata struct to CacheEntry.h that stores namespace and key name pointers:

```cpp
struct KeyMetadata {
    const char* namespace_name = nullptr;
    const char* key_name = nullptr;
};

static inline std::array<KeyMetadata, MAX_KEYS> key_metadata;
```

Update the register_key() function to accept and store metadata:

```cpp
inline size_t register_key(const char* ns, const char* key) {
    size_t id = next_key_id++;
    key_metadata[id] = {ns, key};
    return id;
}
```

Update get_key_id() in QPreferences.h to pass namespace/key to register_key():

```cpp
template<typename KeyType>
size_t get_key_id() {
    static size_t id = QPreferences::register_key(
        KeyType::namespace_name,
        KeyType::key_name
    );
    return id;
}
```

This enables save() to know the namespace and key name for each cache entry without template context.
  </action>
  <verify>Build compiles without errors. Existing get/set/isModified/isDirty still work.</verify>
  <done>KeyMetadata struct exists. register_key() stores namespace/key. get_key_id() passes metadata.</done>
</task>

<task type="auto">
  <name>Task 2: Implement save() with namespace batching and default removal</name>
  <files>src/QPreferences/QPreferences.h, test/save_test/save_test.ino</files>
  <action>
Add save() function to QPrefs namespace in QPreferences.h:

```cpp
inline void save() {
    Preferences prefs;
    const char* current_namespace = nullptr;

    for (size_t i = 0; i < QPreferences::next_key_id; ++i) {
        auto& entry = QPreferences::cache_entries[i];
        auto& meta = QPreferences::key_metadata[i];

        // Skip uninitialized or clean entries
        if (!entry.is_initialized() || !entry.is_dirty()) {
            continue;
        }

        // Switch namespace if needed (batch writes to same namespace)
        if (current_namespace == nullptr ||
            strcmp(current_namespace, meta.namespace_name) != 0) {
            if (current_namespace != nullptr) {
                prefs.end();  // Close previous namespace
            }
            prefs.begin(meta.namespace_name, false);  // false = read-write
            current_namespace = meta.namespace_name;
        }

        // Write or remove based on value (type dispatch via std::visit)
        std::visit([&](auto&& val) {
            using T = std::decay_t<decltype(val)>;
            // Get default value from nvs_value if it was default, otherwise compare
            // For simplicity: always write since we can't easily get default here
            // Note: Default comparison requires knowing the PrefKey, handled below
        }, entry.value);

        // Update nvs_value and clear dirty flag
        entry.nvs_value = entry.value;
        entry.dirty = false;
    }

    if (current_namespace != nullptr) {
        prefs.end();  // Close final namespace
    }
}
```

IMPORTANT: For default value comparison, add a per-key save function:

```cpp
template<typename KeyType>
void save(const KeyType& key) {
    using T = typename KeyType::value_type;
    auto& entry = QPreferences::cache_entries[detail::get_key_id<KeyType>()];
    auto& meta = QPreferences::key_metadata[detail::get_key_id<KeyType>()];

    if (!entry.is_initialized() || !entry.is_dirty()) {
        return;  // Nothing to save
    }

    Preferences prefs;
    prefs.begin(meta.namespace_name, false);

    T current = std::get<T>(entry.value);

    if (current == key.default_value) {
        // Remove from NVS if equals default
        prefs.remove(meta.key_name);
        entry.nvs_value = std::nullopt;
    } else {
        // Write to NVS
        if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, int>) {
            prefs.putInt(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, float>) {
            prefs.putFloat(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, bool>) {
            prefs.putBool(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, String>) {
            prefs.putString(meta.key_name, current);
        }
        entry.nvs_value = entry.value;
    }

    prefs.end();
    entry.dirty = false;
}
```

For the global save() without default comparison, implement a simpler version that always writes non-default by storing a "is_default" flag, OR make save() require passing all keys. The simpler approach: save() writes all dirty values (no default removal), and save(key) does default removal.

Create test sketch test/save_test/save_test.ino:

```cpp
#include <QPreferences.h>

// Define test keys
PrefKey<int, "test", "count"> testCount{0};
PrefKey<bool, "test", "flag"> testFlag{false};
PrefKey<String, "other", "name"> otherName{""};

void setup() {
    Serial.begin(115200);
    delay(1000);

    Serial.println("=== Save Test ===");

    // Test 1: Set values and verify dirty
    QPrefs::set(testCount, 42);
    QPrefs::set(testFlag, true);
    Serial.printf("After set - isDirty(count): %d\n", QPrefs::isDirty(testCount));
    Serial.printf("After set - isDirty(flag): %d\n", QPrefs::isDirty(testFlag));

    // Test 2: Save single key and verify dirty cleared
    QPrefs::save(testCount);
    Serial.printf("After save(count) - isDirty(count): %d\n", QPrefs::isDirty(testCount));
    Serial.printf("After save(count) - isDirty(flag): %d (should still be 1)\n", QPrefs::isDirty(testFlag));

    // Test 3: Set to default and save (should remove from NVS)
    QPrefs::set(testCount, 0);  // Back to default
    QPrefs::save(testCount);
    Serial.printf("After save(0) - isDirty(count): %d\n", QPrefs::isDirty(testCount));

    // Test 4: Different namespaces
    QPrefs::set(otherName, "hello");
    QPrefs::save(testFlag);
    QPrefs::save(otherName);
    Serial.printf("After save all - isDirty(flag): %d\n", QPrefs::isDirty(testFlag));
    Serial.printf("After save all - isDirty(name): %d\n", QPrefs::isDirty(otherName));

    Serial.println("=== Test Complete ===");
}

void loop() {}
```

Ensure platformio.ini has test_save_test entry if needed.
  </action>
  <verify>pio run -e esp32dev compiles. Upload and run save_test sketch - all isDirty() return 0 after save().</verify>
  <done>save(key) persists single key with default removal. isDirty() returns false after save(). Test demonstrates behavior.</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `pio run -e esp32dev` compiles without errors
2. Run save_test sketch and observe:
   - isDirty() returns true after set()
   - isDirty() returns false after save()
   - Setting value to default and saving removes from NVS (verified by reboot test)
3. Existing cache_test still works (backward compatibility)
</verification>

<success_criteria>
- save(key) function exists and compiles
- After save(key), isDirty(key) returns false
- Values equal to default are removed from NVS (not written)
- Test sketch demonstrates all save behaviors
- No regressions in existing get/set/isModified/isDirty APIs
</success_criteria>

<output>
After completion, create `.planning/phases/03-smart-persistence/03-01-SUMMARY.md`
</output>

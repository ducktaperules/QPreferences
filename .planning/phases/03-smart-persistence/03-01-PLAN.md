---
phase: 03-smart-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/QPreferences/CacheEntry.h
  - src/QPreferences/QPreferences.h
  - test/save_test/save_test.ino
autonomous: true

must_haves:
  truths:
    - "After reboot, previously saved non-default values are loaded into RAM on first get() access (lazy loading from Phase 2 satisfies PERS-01)"
    - "Developer can call save(key) to persist a single dirty value to NVS with default comparison"
    - "Developer can call save() to persist all dirty values to NVS in single operation (PERS-05)"
    - "After save() completes, isDirty() returns false for all saved keys"
    - "When saved value matches default, the key is removed from NVS (not stored) - applies to save(key)"
    - "Multiple dirty keys in same namespace are written in single begin/end cycle (batched)"
    - "Test sketch verifies persistence survives reboot (manual reboot step)"
  artifacts:
    - path: "src/QPreferences/CacheEntry.h"
      provides: "KeyMetadata struct and metadata array"
      contains: "KeyMetadata"
    - path: "src/QPreferences/QPreferences.h"
      provides: "save(key) and save() functions"
      contains: ["void save(const KeyType& key)", "void save()"]
    - path: "test/save_test/save_test.ino"
      provides: "Verification sketch for save behavior including batch save and reboot test"
      contains: ["QPrefs::save(", "QPrefs::save()"]
  key_links:
    - from: "src/QPreferences/QPreferences.h"
      to: "cache_entries + key_metadata"
      via: "save() iterates cache entries and groups by namespace"
      pattern: "for.*cache_entries.*key_metadata"
    - from: "save()"
      to: "Preferences.begin/end"
      via: "namespace batching with single begin/end per namespace"
      pattern: "prefs\\.begin.*prefs\\.end"
    - from: "save(key)"
      to: "Preferences.putX/remove"
      via: "type dispatch and default comparison"
      pattern: "prefs\\.(put|remove)"
---

<objective>
Implement explicit save API with both per-key saves and batch saves with namespace grouping.

Purpose: Complete the persistence layer so changes in RAM can be explicitly persisted to flash with minimal flash wear. This enables the "RAM-first, explicit-save" pattern that prevents flash wear from frequent set() calls.

Two save functions:
- `save(key)` - Persist a single key with default value comparison (removes key if value equals default)
- `save()` - Persist all dirty keys in a single operation, batched by namespace for minimal flash wear

Note on PERS-01 (boot loading): Phase 2's lazy initialization pattern already satisfies this requirement. When get(key) is called for the first time after boot, it loads the NVS value into RAM. This is lazy loading rather than eager loading, but achieves the same outcome: stored values are available in RAM when accessed. No additional work needed.

Output:
- KeyMetadata struct storing namespace/key pointers per cache entry
- save(key) function that persists a single key with default removal
- save() function that persists all dirty keys with namespace batching (PERS-05)
- Default value optimization in save(key) (remove key from NVS if value equals default)
- Test sketch demonstrating both save functions with reboot verification instructions
</objective>

<execution_context>
@C:\Users\duckt\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\duckt\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-smart-persistence/03-RESEARCH.md
@.planning/phases/02-ram-cache-dirty-tracking/02-01-SUMMARY.md
@src/QPreferences/CacheEntry.h
@src/QPreferences/QPreferences.h
@src/QPreferences/PrefKey.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add KeyMetadata and update cache registration</name>
  <files>src/QPreferences/CacheEntry.h, src/QPreferences/QPreferences.h</files>
  <action>
Add KeyMetadata struct to CacheEntry.h that stores namespace and key name pointers:

```cpp
struct KeyMetadata {
    const char* namespace_name = nullptr;
    const char* key_name = nullptr;
};

static inline std::array<KeyMetadata, MAX_KEYS> key_metadata;
```

Update the register_key() function to accept and store metadata:

```cpp
inline size_t register_key(const char* ns, const char* key) {
    size_t id = next_key_id++;
    key_metadata[id] = {ns, key};
    return id;
}
```

Update get_key_id() in QPreferences.h to pass namespace/key to register_key():

```cpp
template<typename KeyType>
size_t get_key_id() {
    static size_t id = QPreferences::register_key(
        KeyType::namespace_name,
        KeyType::key_name
    );
    return id;
}
```

This enables save() to iterate cache entries and know the namespace/key name for each entry without template context.
  </action>
  <verify>Build compiles without errors. Existing get/set/isModified/isDirty still work.</verify>
  <done>KeyMetadata struct exists. register_key() stores namespace/key. get_key_id() passes metadata.</done>
</task>

<task type="auto">
  <name>Task 2: Implement save(key) and save() functions</name>
  <files>src/QPreferences/QPreferences.h, test/save_test/save_test.ino</files>
  <action>
Add BOTH save functions to QPrefs namespace in QPreferences.h:

**1. save(key) - Per-key save with default comparison:**

```cpp
/**
 * @brief Persist a single preference key to NVS flash.
 *
 * If the current value equals the default, removes the key from NVS (PERS-04).
 * If the current value differs from default, writes to NVS.
 * After save, isDirty(key) returns false.
 *
 * @tparam KeyType The PrefKey type (automatically deduced)
 * @param key The preference key to save
 */
template<typename KeyType>
void save(const KeyType& key) {
    using T = typename KeyType::value_type;
    auto& entry = QPreferences::cache_entries[detail::get_key_id<KeyType>()];
    auto& meta = QPreferences::key_metadata[detail::get_key_id<KeyType>()];

    if (!entry.is_initialized() || !entry.is_dirty()) {
        return;  // Nothing to save
    }

    Preferences prefs;
    prefs.begin(meta.namespace_name, false);  // false = read-write

    T current = std::get<T>(entry.value);

    if (current == key.default_value) {
        // Remove from NVS if equals default (PERS-04)
        prefs.remove(meta.key_name);
        entry.nvs_value = std::monostate{};  // Mark as no NVS value
    } else {
        // Write to NVS
        if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, int>) {
            prefs.putInt(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, float>) {
            prefs.putFloat(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, bool>) {
            prefs.putBool(meta.key_name, current);
        } else if constexpr (std::is_same_v<T, String>) {
            prefs.putString(meta.key_name, current);
        }
        entry.nvs_value = entry.value;
    }

    prefs.end();
    entry.dirty = false;
}
```

**2. save() - Batch save with namespace grouping (PERS-05):**

This implements Pattern 1 from 03-RESEARCH.md (Namespace-Grouped Batch Write).
Note: Without template context, we cannot compare to defaults, so batch save always writes the value.
Users who want default removal should use save(key) for individual keys.

```cpp
/**
 * @brief Persist all dirty preference values to NVS flash in a single operation.
 *
 * Groups dirty entries by namespace and writes all entries in the same namespace
 * within a single begin/end cycle to minimize flash wear (PERS-05).
 *
 * Note: Unlike save(key), this function does NOT perform default value comparison
 * because it operates without template context. Values are always written.
 * Use save(key) for individual keys if you want default removal behavior.
 *
 * After save() completes, isDirty() returns false for all saved keys.
 */
inline void save() {
    Preferences prefs;
    const char* current_namespace = nullptr;

    for (size_t i = 0; i < QPreferences::cache_entries.size(); ++i) {
        auto& entry = QPreferences::cache_entries[i];

        // Skip uninitialized or clean entries
        if (!entry.is_initialized() || !entry.is_dirty()) {
            continue;
        }

        auto& meta = QPreferences::key_metadata[i];

        // Open new namespace if needed (namespace batching)
        if (current_namespace == nullptr || strcmp(current_namespace, meta.namespace_name) != 0) {
            if (current_namespace != nullptr) {
                prefs.end();  // Close previous namespace
            }
            prefs.begin(meta.namespace_name, false);  // false = read-write
            current_namespace = meta.namespace_name;
        }

        // Write value based on type stored in variant
        std::visit([&prefs, &meta, &entry](auto&& val) {
            using T = std::decay_t<decltype(val)>;
            if constexpr (std::is_same_v<T, std::monostate>) {
                // Uninitialized - shouldn't happen due to is_initialized() check
            } else if constexpr (std::is_same_v<T, int32_t> || std::is_same_v<T, int>) {
                prefs.putInt(meta.key_name, val);
                entry.nvs_value = val;
            } else if constexpr (std::is_same_v<T, float>) {
                prefs.putFloat(meta.key_name, val);
                entry.nvs_value = val;
            } else if constexpr (std::is_same_v<T, bool>) {
                prefs.putBool(meta.key_name, val);
                entry.nvs_value = val;
            } else if constexpr (std::is_same_v<T, String>) {
                prefs.putString(meta.key_name, val);
                entry.nvs_value = val;
            }
        }, entry.value);

        entry.dirty = false;  // Clear dirty flag after write
    }

    if (current_namespace != nullptr) {
        prefs.end();  // Close final namespace
    }
}
```

**Test sketch** - Create test/save_test/save_test.ino:

```cpp
#include <QPreferences.h>

// Define test keys in same namespace for batching test
PrefKey<int, "test", "count"> testCount{0};
PrefKey<bool, "test", "flag"> testFlag{false};
PrefKey<int, "test", "value"> testValue{100};
// Different namespace to verify namespace switching
PrefKey<String, "other", "name"> otherName{""};

void setup() {
    Serial.begin(115200);
    delay(1000);

    Serial.println("=== Save Test ===");

    // Check if this is a reboot test (value should persist)
    int initialCount = QPrefs::get(testCount);
    Serial.printf("Initial count (from NVS or default): %d\n", initialCount);

    if (initialCount == 42) {
        Serial.println("SUCCESS: Value persisted across reboot!");
        Serial.println("Resetting to default for next test run...");
        QPrefs::set(testCount, 0);
        QPrefs::set(testFlag, false);
        QPrefs::set(testValue, 100);
        QPrefs::save();  // Batch save to reset
        Serial.println("Reset complete. Test passed.");
        return;
    }

    // Test 1: Set multiple values and verify dirty
    Serial.println("\n--- Test 1: Set values ---");
    QPrefs::set(testCount, 42);
    QPrefs::set(testFlag, true);
    QPrefs::set(testValue, 200);
    QPrefs::set(otherName, "hello");
    Serial.printf("isDirty(count): %d (expect 1)\n", QPrefs::isDirty(testCount));
    Serial.printf("isDirty(flag): %d (expect 1)\n", QPrefs::isDirty(testFlag));
    Serial.printf("isDirty(value): %d (expect 1)\n", QPrefs::isDirty(testValue));
    Serial.printf("isDirty(name): %d (expect 1)\n", QPrefs::isDirty(otherName));

    // Test 2: Batch save() - all dirty keys saved in single operation
    Serial.println("\n--- Test 2: Batch save() ---");
    QPrefs::save();  // Saves all dirty keys with namespace batching
    Serial.printf("After save() - isDirty(count): %d (expect 0)\n", QPrefs::isDirty(testCount));
    Serial.printf("After save() - isDirty(flag): %d (expect 0)\n", QPrefs::isDirty(testFlag));
    Serial.printf("After save() - isDirty(value): %d (expect 0)\n", QPrefs::isDirty(testValue));
    Serial.printf("After save() - isDirty(name): %d (expect 0)\n", QPrefs::isDirty(otherName));

    // Test 3: Per-key save(key) with default removal
    Serial.println("\n--- Test 3: save(key) with default removal ---");
    QPrefs::set(testFlag, false);  // Back to default
    Serial.printf("Set flag to default - isDirty(flag): %d (expect 1)\n", QPrefs::isDirty(testFlag));
    QPrefs::save(testFlag);  // Should remove from NVS since equals default
    Serial.printf("After save(flag) - isDirty(flag): %d (expect 0)\n", QPrefs::isDirty(testFlag));

    // Test 4: Verify only dirty keys are saved
    Serial.println("\n--- Test 4: Only dirty keys saved ---");
    QPrefs::set(testCount, 99);  // Make dirty
    // testFlag is clean, testValue is clean
    Serial.printf("isDirty(count): %d (expect 1)\n", QPrefs::isDirty(testCount));
    Serial.printf("isDirty(flag): %d (expect 0)\n", QPrefs::isDirty(testFlag));
    QPrefs::set(testCount, 42);  // Change back for reboot test
    QPrefs::save();  // Only count should be written
    Serial.printf("After save() - isDirty(count): %d (expect 0)\n", QPrefs::isDirty(testCount));

    Serial.println("\n=== Reboot Test Instructions ===");
    Serial.println("1. Press reset button or power cycle");
    Serial.println("2. After reboot, count should be 42 (persisted)");
    Serial.println("3. The test will detect this and report SUCCESS");
    Serial.println("=== Test Complete - Please Reboot ===");
}

void loop() {}
```

Ensure platformio.ini has save_test environment.
  </action>
  <verify>pio run -e esp32dev compiles. Upload and run save_test sketch - all isDirty() return 0 after save(). After reboot, value 42 persists.</verify>
  <done>save(key) persists single key with default removal. save() persists all dirty keys with namespace batching. isDirty() returns false after both save functions. Test demonstrates all behaviors including reboot verification.</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `pio run -e esp32dev` compiles without errors
2. Run save_test sketch and observe:
   - isDirty() returns true after set()
   - isDirty() returns false after save() (batch)
   - isDirty() returns false after save(key) (per-key)
   - Multiple keys in same namespace are batched in single begin/end cycle
   - Setting value to default and using save(key) removes from NVS
3. Reboot test:
   - After first run with value 42, reboot device
   - On second run, initial get() should return 42 (loaded from NVS)
   - This verifies PERS-01 (boot loading via lazy init)
4. Existing cache_test still works (backward compatibility)
</verification>

<success_criteria>
- save(key) function exists and compiles - persists single key with default comparison
- save() function exists and compiles - persists all dirty keys with namespace batching
- After save() (batch), isDirty() returns false for ALL previously dirty keys
- After save(key), isDirty(key) returns false for that specific key
- Values equal to default are removed from NVS when using save(key)
- Multiple dirty keys in same namespace are written in single begin/end cycle
- After reboot, non-default values are loaded from NVS on first get()
- Test sketch demonstrates all save behaviors including batch save and reboot persistence
- No regressions in existing get/set/isModified/isDirty APIs
</success_criteria>

<output>
After completion, create `.planning/phases/03-smart-persistence/03-01-SUMMARY.md`
</output>
